import joblib
import ipfshttpclient
from web3 import Web3
import json
import os
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import  classification_report
import pandas as pd
import numpy


# --- Configuration (replace with your actual values) ---
# Replace with the contract address obtained from Part 2 deployment
CONTRACT_ADDRESS = "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0" # Example, replace!

# Path to your contract's ABI file (generated by Hardhat)
ABI_FILE_PATH = "./artifacts/contracts/MLModelRegistry.sol/MLModelRegistry.json"

# Connect to a local Hardhat node (default URL when `npx hardhat node` is running)
# Or connect to a testnet/mainnet RPC URL (e.g., Infura, Alchemy)
WEB3_PROVIDER_URL = "http://127.0.0.1:8545/" # Hardhat's default local RPC

# --- 1. Connect to Web3 provider and Smart Contract ---
print("1. Connecting to blockchain...")
w3 = Web3(Web3.HTTPProvider(WEB3_PROVIDER_URL))

if not w3.is_connected():
    print("Failed to connect to Web3 provider. Ensure your blockchain node is running.")
    exit()

print("Connected to blockchain.")

# Load ABI
try:
    with open(ABI_FILE_PATH, 'r') as f:
        contract_abi = json.load(f)['abi']
except FileNotFoundError:
    print(f"Error: ABI file not found at {ABI_FILE_PATH}. Please ensure you've compiled your contract with Hardhat.")
    exit()

# Create contract instance
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=contract_abi)
print(f"Connected to MLModelRegistry contract at {CONTRACT_ADDRESS}")

# --- 2. Retrieve IPFS CID from the Smart Contract ---
print("\n2. Retrieving model information from the smart contract...")
try:
    ipfs_cid, version, description, timestamp, deployer = contract.functions.getLatestModel().call()
    
    if not ipfs_cid:
        print("No model registered yet in the smart contract.")
        exit()

    print(f"Retrieved from contract:")
    print(f"  IPFS CID: {ipfs_cid}")
    print(f"  Version: {version}")
    print(f"  Description: {description}")
    print(f"  Deployed by: {deployer} at {timestamp} (UTC)")

except Exception as e:
    print(f"Error retrieving model from contract: {e}")
    exit()

# --- 3. Fetch the model from IPFS ---
print(f"\n3. Fetching model from IPFS using CID: {ipfs_cid}...")
model = None
download_path = "downloaded_model.pkl"
try:
    client = ipfshttpclient.connect('/ip4/127.0.0.1/tcp/5001/http')
    
    # Use client.cat() to get the content bytes
    model_bytes = client.cat(ipfs_cid)

    # Save bytes to a file
    with open(download_path, 'wb') as f:
        f.write(model_bytes)
    
    print(f"Model downloaded to {download_path}")

    # Load the model from the downloaded file
    model = joblib.load(download_path)
    print("Model loaded successfully from IPFS.")

except Exception as e:
    print(f"Error connecting to IPFS or fetching model: {e}")
    print("Ensure your IPFS daemon is running and the CID is valid.")
finally:
    # Clean up the downloaded local file
    if os.path.exists(download_path):
        os.remove(download_path)
        print(f"Cleaned up local downloaded file: {download_path}")

# --- 4. Use the loaded ML model for inference ---
if model:
    print("\n4. Performing inference with the loaded model:")
    X_test = pd.read_csv('X_test.csv')
    y_test = pd.read_csv('y_test.csv')

    y_predicted_lr = model.predict(X_test)
    print("Testing Accuracy :", model.score(X_test, y_test))
    cr = classification_report(y_test, y_predicted_lr)
    print(cr)


    print("\nInference complete.")
else:
    print("\nCould not load model for inference.")